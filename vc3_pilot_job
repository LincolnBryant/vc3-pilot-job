#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

use autodie;

use Carp qw/carp croak/;
use B;

use File::Spec;
use File::Basename;
use File::Path;

use Getopt::Long qw/GetOptions/;

my $vc3_root       = $ENV{VC3_ROOT}       || "vc3_root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "$vc3_root/distfiles";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://ccl.cse.nd.edu/vc3_repo";

my $vc3_environment = {};

main();

sub main {
    my $catalog = 'vc3_catalog.json';

    GetOptions("catalog=s" => \$catalog);

    my ($goal_pkg, @command_and_args) = @ARGV;

    my $specs = decode_specs($catalog);

    %ENV = ();
    build_tarball($goal_pkg, $specs);

    exec qq(@command_and_args);
}

sub decode_specs {
    my ($filename) = @_;
    open( my $specs_f, '<:encoding(UTF-8)', $filename); 
    my $contents = do { local($/); <$specs_f> };
    close($specs_f);

    return JSON::Tiny::decode_json($contents);
}

sub architecture {
    chomp (my $architecture = qx(/bin/uname -m));
    $architecture
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my $distribution='non-redhat';
    
    if (-f '/etc/redhat-release') {
	open (my $file_fh, '<', '/etc/redhat-release');
	my $redhat_version_line = <$file_fh>;
	
	$redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
	my $redhat_version = $1;

	die 'Could not find redhat version!' unless $redhat_version;
	
	$distribution="redhat${redhat_version}"
    }
    
    $distribution;
}

sub target {
    my $target = architecture . '/' . distribution;
    $target
}

sub prefix {
    my $pkg = shift;

    croak "pkg not specified!\n" unless $pkg->{name};
    
    File::Spec->rel2abs($vc3_root) . '/' . target . '/' . $pkg->{name} . $pkg->{version};
}

sub completion_ribbon {
    my $pkg = shift;
    my $ribbon 
	= $vc3_root
	. '/' 
	. target
	. '/' 
	. $pkg->{name}  
	. $pkg->{version}  
	. '/.VC3_DEPENDENCY_BUILD_COMPLETE';
}

# range is: [min_version, max_version];
# max_version is the prefered version. 
# [version] is considered as [version, version]
sub check_version {
    my ($pkg, @range) = @_;

    return 1 unless $pkg->{versioncmd};
    return 1 unless $pkg->{version} || @range > 0;

    if(@range == 0) {
        @range = (version->parse($pkg->{version}));
    }

    my $reg = $pkg->{versionreg} ? $pkg->{versionreg} : qr/(.*)/;

    my $version_output = qx/$pkg->{versioncmd}/;

    return 0 unless $version_output =~ $reg;

    my ($observed_version) = version->parse("$1");

    print $observed_version . "\n";

    return 0 if $observed_version < $range[0];
    return 0 if $observed_version > $range[$#range];

    return $observed_version;
}


sub build_tarball {
    my ($pkg_name, $specs) = @_;

    my $pkg = $specs->{$pkg_name} 
    || croak "I do not know how to make '$pkg_name'.";

    if($pkg->{dependencies}) {
        for my $dependency (keys %{$pkg->{dependencies}}) {
            build_tarball($dependency, $specs);
        }
    }

    unless(-f completion_ribbon($pkg)) {
        my $prefix = prefix($pkg);
        my $name   = File::Basename::basename($prefix);
        my $build  = "${vc3_root}/builds/${name}";

        my $tarball_spec = $pkg->{source}[0]
        || croak "This spec does not have a tarball defined.";

        my $tarball = $tarball_spec->{tarball}
        || croak "No tarball is defined for $name.";

        my $recipe = $tarball_spec->{recipe}
        || croak "No recipe to build $name.";
        
        $tarball = File::Spec->rel2abs( $vc3_distfiles . "/$tarball");
        croak "Could not find $tarball!" unless -f $tarball;

        print "Building ${name} from $tarball for ", target, "\n";

        if( -d $build ) {
            File::Path::rmtree($build);
        }

        my $sh_out;
        File::Path::make_path($prefix);
        $sh_out = qx(mkdir -p ${build} && /bin/tar -C ${build} --strip-components=1 -xpf ${tarball});
        if($?) {
            croak "Could not expand tarball $tarball:\n$sh_out\n";
        }

        $ENV{'VC3_PREFIX'} = $prefix;

        printf "${build}\n";
        $sh_out = qx^cd ${build} && ($recipe)^;
        if ($?) {
            print "$name failed to build for ", target, "\n";
            return $?;
        }

        open (my $ribbon_fh, '>', completion_ribbon($pkg));
        close $ribbon_fh;
    }

    append_environment($pkg);
}

sub append_environment {
    my ($pkg) = @_; 

    my $root_name = 'VC3_' . uc($pkg->{name}) . '_ROOT';

    $vc3_environment->{$root_name} = prefix($pkg);
    $ENV{$root_name} = $vc3_environment->{$root_name};

    my $appends = $pkg->{env_append}
    || return;

    for my $varname (keys %{$appends}) {
        $vc3_environment->{$varname} = {} unless $vc3_environment;

        my $value = prefix($pkg) . '/' . $appends->{$varname};

        # we keep a hash as a set of added paths of environment variables
        $vc3_environment->{$varname}{$value} = 1;

        my $dotted = join(':', keys %{$vc3_environment->{$varname}});
        $ENV{$varname} = $dotted;
    }
}

package Perl::Version;
use SelfLoader;

package JSON::Tiny;
use SelfLoader;

__DATA__
##### JSON encoding/decoding module:

package JSON::Tiny;

# Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
# License: Artistic 2.0 license.
# http://www.perlfoundation.org/artistic_license_2_0

use strict;
use warnings;
use utf8;
use B qw/svref_2object/;
use Carp qw/carp croak/;
use Exporter 'import';
use Scalar::Util 'blessed';
use Encode ();

our $VERSION = '0.53';
our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);

# Literal names
# Users may override Booleans with literal 0 or 1 if desired.
our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;

# Escaped special character map with u2028 and u2029
my %ESCAPE = (
  '"'     => '"',
  '\\'    => '\\',
  '/'     => '/',
  'b'     => "\x08",
  'f'     => "\x0c",
  'n'     => "\x0a",
  'r'     => "\x0d",
  't'     => "\x09",
  'u2028' => "\x{2028}",
  'u2029' => "\x{2029}"
);
my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;

for(0x00 .. 0x1f) {
  my $packed = pack 'C', $_;
  $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
}

sub decode_json {
  my $err = _decode(\my $value, shift);
  return defined $err ? Carp::croak $err : $value;
}

sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }

sub false () {$FALSE}  ## no critic (prototypes)

sub from_json {
  my $err = _decode(\my $value, shift, 1);
  return defined $err ? Carp::croak $err : $value;
}

sub j {
  return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
  return decode_json $_[0];
}

sub to_json { _encode_value(shift) }

sub true () {$TRUE} ## no critic (prototypes)

sub _decode {
  my $valueref = shift;

  eval {

    # Missing input
    die "Missing or empty input\n" unless length( local $_ = shift );

    # UTF-8
    $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
    die "Input is not UTF-8 encoded\n" unless defined $_;

    # Value
    $$valueref = _decode_value();
  
    # Leftover data
    return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
  } ? return undef : chomp $@;

  return $@;
}

sub _decode_array {
  my @array;
  until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {

    # Value
    push @array, _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\]/gc;

    # Invalid character
    _throw('Expected comma or right square bracket while parsing array');
  }

  return \@array;
}

sub _decode_object {
  my %hash;
  until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {

    # Quote
    m/\G[\x20\x09\x0a\x0d]*"/gc
      or _throw('Expected string while parsing object');

    # Key
    my $key = _decode_string();

    # Colon
    m/\G[\x20\x09\x0a\x0d]*:/gc
      or _throw('Expected colon while parsing object');

    # Value
    $hash{$key} = _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\}/gc;

    # Invalid character
    _throw('Expected comma or right curly bracket while parsing object');
  }

  return \%hash;
}

sub _decode_string {
  my $pos = pos;
  
  # Extract string with escaped characters
  m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
  my $str = $1;

  # Invalid character
  unless (m/\G"/gc) {
    _throw('Unexpected character or invalid escape while parsing string')
      if m/\G[\x00-\x1f\\]/;
    _throw('Unterminated string');
  }

  # Unescape popular characters
  if (index($str, '\\u') < 0) {
    $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
    return $str;
  }

  # Unescape everything else
  my $buffer = '';
  while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
    $buffer .= $1;

    # Popular character
    if ($2) { $buffer .= $ESCAPE{$2} }

    # Escaped
    else {
      my $ord = hex $3;

      # Surrogate pair
      if (($ord & 0xf800) == 0xd800) {

        # High surrogate
        ($ord & 0xfc00) == 0xd800
          or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');

        # Low surrogate
        $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
          or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');

        $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
      }

      # Character
      $buffer .= pack 'U', $ord;
    }
  }

  # The rest
  return $buffer . substr $str, pos $str, length $str;
}

sub _decode_value {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # String
  return _decode_string() if m/\G"/gc;

  # Object
  return _decode_object() if m/\G\{/gc;

  # Array
  return _decode_array() if m/\G\[/gc;

  # Number
  return 0 + $1
    if m/\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;

  # True
  return $TRUE if m/\Gtrue/gc;

  # False
  return $FALSE if m/\Gfalse/gc;

  # Null
  return undef if m/\Gnull/gc;  ## no critic (return)

  # Invalid character
  _throw('Expected string, array, object, number, boolean or null');
}

sub _encode_array {
  '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
}

sub _encode_object {
  my $object = shift;
  my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
    keys %$object;
  return '{' . join(',', @pairs) . '}';
}

sub _encode_string {
  my $str = shift;
  $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
  return "\"$str\"";
}

sub _encode_value {
  my $value = shift;

  # Reference
  if (my $ref = ref $value) {

    # Object
    return _encode_object($value) if $ref eq 'HASH';

    # Array
    return _encode_array($value) if $ref eq 'ARRAY';

    # True or false
    return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
    return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';

    # Blessed reference with TO_JSON method
    if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
      return _encode_value($value->$sub);
    }
  }

  # Null
  return 'null' unless defined $value;

  # Number
  return $value
    if B::svref_2object(\$value)->FLAGS & (B::SVp_IOK | B::SVp_NOK)
    && 0 + $value eq $value
    && $value * 0 == 0;

  # String
  return _encode_string($value);
}

sub _throw {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # Context
  my $context = 'Malformed JSON: ' . shift;
  if (m/\G\z/gc) { $context .= ' before end of data' }
  else {
    my @lines = split "\n", substr($_, 0, pos);
    $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
  }

  die "$context\n";
}

# Emulate boolean type
package JSON::Tiny::_Bool;
use overload '""' => sub { ${$_[0]} }, fallback => 1;
1;

package version;

use 5.006002;
use strict;
use warnings::register;
if ($] >= 5.015) {
    warnings::register_categories(qw/version/);
}

use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);

$VERSION = 0.9917;
$CLASS = 'version';

# !!!!Delete this next block completely when adding to Perl core!!!!
{
    local $SIG{'__DIE__'};
    eval "use version::vxs $VERSION";
    if ( $@ ) { # don't have the XS version installed
	eval "use version::vpp $VERSION"; # don't tempt fate
	die "$@" if ( $@ );
	push @ISA, "version::vpp";
	local $^W;
	*version::qv = \&version::vpp::qv;
	*version::declare = \&version::vpp::declare;
	*version::_VERSION = \&version::vpp::_VERSION;
	*version::vcmp = \&version::vpp::vcmp;
	*version::new = \&version::vpp::new;
	*version::numify = \&version::vpp::numify;
	*version::normal = \&version::vpp::normal;
	if ($] >= 5.009000) {
	    no strict 'refs';
	    *version::stringify = \&version::vpp::stringify;
	    *{'version::(""'} = \&version::vpp::stringify;
	    *{'version::(<=>'} = \&version::vpp::vcmp;
	    *{'version::(cmp'} = \&version::vpp::vcmp;
	    *version::parse = \&version::vpp::parse;
	}
    }
    else { # use XS module
	push @ISA, "version::vxs";
	local $^W;
	*version::declare = \&version::vxs::declare;
	*version::qv = \&version::vxs::qv;
	*version::_VERSION = \&version::vxs::_VERSION;
	*version::vcmp = \&version::vxs::VCMP;
	*version::new = \&version::vxs::new;
	*version::numify = \&version::vxs::numify;
	*version::normal = \&version::vxs::normal;
	if ($] >= 5.009000) {
	    no strict 'refs';
	    *version::stringify = \&version::vxs::stringify;
	    *{'version::(""'} = \&version::vxs::stringify;
	    *{'version::(<=>'} = \&version::vxs::VCMP;
	    *{'version::(cmp'} = \&version::vxs::VCMP;
	    *version::parse = \&version::vxs::parse;
	}
    }
}

# avoid using Exporter
require version::regex;
*version::is_lax = \&version::regex::is_lax;
*version::is_strict = \&version::regex::is_strict;
*LAX = \$version::regex::LAX;
*STRICT = \$version::regex::STRICT;

sub import {
    no strict 'refs';
    my ($class) = shift;

    # Set up any derived class
    unless ($class eq $CLASS) {
	local $^W;
	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
	*{$class.'::qv'} = \&{$CLASS.'::qv'};
    }

    my %args;
    if (@_) { # any remaining terms are arguments
	map { $args{$_} = 1 } @_
    }
    else { # no parameters at all on use line
	%args =
	(
	    qv => 1,
	    'UNIVERSAL::VERSION' => 1,
	);
    }

    my $callpkg = caller();

    if (exists($args{declare})) {
	*{$callpkg.'::declare'} =
	    sub {return $class->declare(shift) }
	  unless defined(&{$callpkg.'::declare'});
    }

    if (exists($args{qv})) {
	*{$callpkg.'::qv'} =
	    sub {return $class->qv(shift) }
	  unless defined(&{$callpkg.'::qv'});
    }

    if (exists($args{'UNIVERSAL::VERSION'})) {
	local $^W;
	*UNIVERSAL::VERSION
		= \&{$CLASS.'::_VERSION'};
    }

    if (exists($args{'VERSION'})) {
	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
    }

    if (exists($args{'is_strict'})) {
	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
	  unless defined(&{$callpkg.'::is_strict'});
    }

    if (exists($args{'is_lax'})) {
	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
	  unless defined(&{$callpkg.'::is_lax'});
    }
}


package version::regex;
use strict;

use vars qw($VERSION $CLASS $STRICT $LAX);

$VERSION = 0.9917;

#--------------------------------------------------------------------------#
# Version regexp components
#--------------------------------------------------------------------------#

# Fraction part of a decimal version number.  This is a common part of
# both strict and lax decimal versions

my $FRACTION_PART = qr/\.[0-9]+/;

# First part of either decimal or dotted-decimal strict version number.
# Unsigned integer with no leading zeroes (except for zero itself) to
# avoid confusion with octal.

my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;

# First part of either decimal or dotted-decimal lax version number.
# Unsigned integer, but allowing leading zeros.  Always interpreted
# as decimal.  However, some forms of the resulting syntax give odd
# results if used as ordinary Perl expressions, due to how perl treats
# octals.  E.g.
#   version->new("010" ) == 10
#   version->new( 010  ) == 8
#   version->new( 010.2) == 82  # "8" . "2"

my $LAX_INTEGER_PART = qr/[0-9]+/;

# Second and subsequent part of a strict dotted-decimal version number.
# Leading zeroes are permitted, and the number is always decimal.
# Limited to three digits to avoid overflow when converting to decimal
# form and also avoid problematic style with excessive leading zeroes.

my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;

# Second and subsequent part of a lax dotted-decimal version number.
# Leading zeroes are permitted, and the number is always decimal.  No
# limit on the numerical value or number of digits, so there is the
# possibility of overflow when converting to decimal form.

my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;

# Alpha suffix part of lax version number syntax.  Acts like a
# dotted-decimal part.

my $LAX_ALPHA_PART = qr/_[0-9]+/;

#--------------------------------------------------------------------------#
# Strict version regexp definitions
#--------------------------------------------------------------------------#

# Strict decimal version number.

my $STRICT_DECIMAL_VERSION =
    qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;

# Strict dotted-decimal version number.  Must have both leading "v" and
# at least three parts, to avoid confusion with decimal syntax.

my $STRICT_DOTTED_DECIMAL_VERSION =
    qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;

# Complete strict version number syntax -- should generally be used
# anchored: qr/ \A $STRICT \z /x

$STRICT =
    qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;

#--------------------------------------------------------------------------#
# Lax version regexp definitions
#--------------------------------------------------------------------------#

# Lax decimal version number.  Just like the strict one except for
# allowing an alpha suffix or allowing a leading or trailing
# decimal-point

my $LAX_DECIMAL_VERSION =
    qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
	|
	$FRACTION_PART $LAX_ALPHA_PART?
    /x;

# Lax dotted-decimal version number.  Distinguished by having either
# leading "v" or at least three non-alpha parts.  Alpha part is only
# permitted if there are at least two non-alpha parts. Strangely
# enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
# so when there is no "v", the leading part is optional

my $LAX_DOTTED_DECIMAL_VERSION =
    qr/
	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
	|
	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
    /x;

# Complete lax version number syntax -- should generally be used
# anchored: qr/ \A $LAX \z /x
#
# The string 'undef' is a special case to make for easier handling
# of return values from ExtUtils::MM->parse_version

$LAX =
    qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;

#--------------------------------------------------------------------------#

# Preloaded methods go here.
sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }

1;


1;

