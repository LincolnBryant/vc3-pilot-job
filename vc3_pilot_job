#! /usr/bin/env perl

use v5.009;
use strict;
use warnings;

use autodie;

package VC3::Bag; 

use Carp qw/carp croak/;

use English qw/-mo_match_vars/;

use File::Spec;

use Getopt::Long qw/GetOptions/;

use version;

use Data::Dumper;

my $vc3_root       = $ENV{VC3_ROOT}       || "vc3_root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "$vc3_root/distfiles";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/repository";

my @external_dependencies = qw/sh tail tar uname/;

my %vc3_environment;

main();

sub usage {
    return <<EOF;
$0 [options] [--catalog software-bag] goal-environment [-- command-and-args]

    environment-bag defaults to ./vc3_catalog.json
    command-and-args    defaults to /bin/sh

    options are:
    --make-jobs=n    default is 2
    --sh-on-error    on building error, run /bin/sh with the build environment

Examples:
    $0 parrot -- parrot_run python examples/read-file-from-cvmfs.py
    $0 python -- /bin/sh

EOF
}

sub main {
    my $catalog      = 'vc3_catalog.json';
    my $print_help   = 0;
    my $make_jobs    = 2;
    my $sh_on_error  = 0;
    my $goal_env_version = 0;

    GetOptions(
        "catalog=s"      => \$catalog,
        "goal-version=s" => \$goal_env_version,
        "make-jobs=n"    => \$make_jobs,
        "sh-on-error"    => \$sh_on_error,
        "help"           => \$print_help,
    );

    if($print_help) {
        print usage();
        exit 0;
    }

    my ($goal_env_name, @command_and_args) = @ARGV;

    if(!$goal_env_name) {
        print "No goal environment given.\n\n" . usage();
        exit 1;
    }

    # set defaults
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
    }

    %ENV = (PATH => '/bin:/usr/bin', HOME => $ENV{PWD}, MAKEFLAGS => "-j${make_jobs}");
    $vc3_environment{PATH}->{'/bin'}     = 1;
    $vc3_environment{PATH}->{'/usr/bin'} = 1;

    # disable stdout buffering
    select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

    my $bag = decode_bag($catalog);

    # bag, goal, min-version, max-version
    set_environment($bag, $goal_env_name, $sh_on_error, $goal_env_version, $goal_env_version);

    delete $ENV{VC3_PREFIX}; 
    delete $ENV{VC3_SOURCE_FILE};

    print "building phase done!\n";
    exec qq(@command_and_args);
}

sub decode_bag {
    my ($filename) = @_;
    open( my $bag_f, '<:encoding(UTF-8)', $filename); 
    my $contents = do { local($/); <$bag_f> };
    close($bag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    my $bag = {};
    
    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($_) } @{$bag_raw->{$widget_name}};
        $bag->{$widget_name} = \@versions;
    }

    return $bag;
}

sub set_environment {
    my ($bag, $widget_name, $sh_on_error, $min_version, $max_version) = @_;

    my $widget_versions = $bag->{$widget_name}
    || croak "I do not know anything about '$widget_name'.";


    my $widget = select_version($widget_name, $widget_versions, $min_version, $max_version);

    set_dependencies($bag, $sh_on_error, $widget->dependencies);

    $widget->set_environment_variables();

    my $status;
    for my $source (@{$widget->sources}) {

        # save current environment so that we can rollback in case of error.
        my %old_ENV = %ENV;
        my %old_vc3_environment = %vc3_environment;

        # set dependencies particular to this source
        set_dependencies($bag, $sh_on_error, $source->dependencies);

        eval {$status = $widget->execute_recipe($source);};
        $status = -1 if $EVAL_ERROR;

        if($status) {
            # on error, reestablish old environment, and show last lines of log
            # file.
            %ENV = %old_ENV;
            my %vc3_environment = %old_vc3_environment;

            $widget->process_error($sh_on_error, $EVAL_ERROR, $status);
        } else {
            # on success, we keep break out and do no try more recipes.
            last;
        }
    }

    # last of the tries also failed, so we report failure for this widget.
    if($status) {
        croak "Could not set environment for '" . $widget->name . "' succesfully'.";
    }
}

sub set_dependencies {
    my ($bag, $sh_on_error, $dependencies) = @_;

    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_dep_ver, $max_dep_ver) = @{$dependencies->{$dependency}};
            set_environment($bag, $dependency, $sh_on_error, $min_dep_ver, $max_dep_ver);
        }
    }
}

# versions available, min desired version, max desired version
sub select_version {
    my ($pkg_name, $pkg_versions, $min_version, $max_version) = @_;

    if($min_version) {
        $min_version = version->parse($min_version);
    }

    if($max_version) {
        $max_version = version->parse($max_version);
    }

    my $min_found;
    my $max_found;

    for my $pkg_version (@{$pkg_versions}) {
        if(!$min_version) {
            return $pkg_version;
        }

        my $version = version->parse($pkg_version->{version});

        $min_found = $version unless $min_found;
        $max_found = $version unless $max_found;

        $min_found = $min_found lt $version ? $version : $min_found;
        $max_found = $max_found gt $version ? $version : $max_found;

        next if $min_version gt $version;

        if(!$max_version) {
            return $pkg_version;
        }

        next if $max_version lt $version;
        return $pkg_version;
    }

    $max_version = $min_version unless $max_version;
    croak "I did not find a suitable version for '$pkg_name'.\n Found: ["
    . version::normal($min_found)
    . ',' . version::normal($max_found)
    . ']. Wanted ['
    . $min_version->normal
    . ',' . $max_version->normal
    . "]\n";
}



sub architecture {
    chomp (my $architecture = qx(/bin/uname -m));
    $architecture
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my $distribution='non-redhat';
    
    if (-f '/etc/redhat-release') {
	open (my $file_fh, '<', '/etc/redhat-release');
	my $redhat_version_line = <$file_fh>;
	
	$redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
	my $redhat_version = $1;

	die 'Could not find redhat version!' unless $redhat_version;
	
	$distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub target {
    my $target = architecture . '/' . distribution;
    return $target;
}

package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";

use Data::Dumper;

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $json_description) = @_;

    my $self = bless {}, $class;

    $self->name($json_description->{name});
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->environment_variables($json_description->{environment_variables});

    add_root_variable($self);

    return $self;
}

sub add_root_variable {
    my ($self) = @_;

    my $vars      = $self->environment_variables || [];
    my $root_name = 'VC3_' . uc($self->name) . '_ROOT';

    my $root_var = {
        name     => $root_name,
        value    => $self->destination_dir,
        clobber  => 1,
        absolute => 1
    };

    unshift @{$vars}, $root_var;

    $self->environment_variables($vars);
}


sub name {
    my ($self, $new_name) = @_;

    $self->{name} = $new_name if($new_name);

    croak 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    $self->{version} = $new_version if($new_version);

    croak 'No version given'
    unless($self->{version}); 

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub destination_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/' . VC3::Bag->target . '/' . $self->name . '-' . $self->version;
}

sub build_dir {
    my ($self) = @_;
    my $build_dir = "${vc3_root}/builds/" . $self->name;

    return $build_dir;
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->destination_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub completion_ribbon {
    my ($self) = @_;
    my $ribbon = $self->destination_dir . '/.VC3_DEPENDENCY_BUILD_COMPLETE';

    return $ribbon;
}

sub set_environment_variables {
    my ($self) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (@{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value    = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if(!$absolute) {
            $value = $self->destination_dir . '/' . $value;
        }

        $value = expand_env_variable($value);

        if($clobber) {
            if($vc3_environment{$name}) {
                carp "Environment variable '$name' already set. Clobbering with new value."
            }
            $vc3_environment{$name} = {};
        }

        $vc3_environment{$name}->{$value} = 1;

        my $dotted = join(':', sort { $a cmp $b } keys %{$vc3_environment{$name}});
        $ENV{$name} = $dotted;
    }
}

sub expand_env_variable {
    my ($varvalue) = @_;

    $varvalue =~ s/\$\{(\w+)\}/$ENV{$1}/g;

    return $varvalue;
}

# range is: [min_version, max_version];
# max_version is the prefered version. 
# [version] is considered as [min_version]
# sub check_version {
#     my ($self, @range) = @_;
# 
#     return 1 unless $self->versioncmd;
#     return 1 unless $self->version || @range > 0;
# 
#     if(@range == 0) {
#         @range = (version->parse($self->{version}));
#     }
# 
#     my $reg = $self->{versionreg} ? $self->{versionreg} : qr/(.*)/;
# 
#     my $version_output = qx/$self->{versioncmd}/;
# 
#     return 0 unless $version_output =~ $reg;
# 
#     my ($observed_version) = version->parse("$1");
# 
#     print $observed_version . "\n";
# 
#     return 0 if $observed_version < $range[0];
#     return 0 if $observed_version > $range[$#range];
# 
#     return $observed_version;
# }

sub error_debug_info {
    my ($self) = @_;

    print "'" . $self->name . "' failed to build for ", VC3::Bag::target, "\n";
    print "Last lines of log file:\n";
    system('tail', $self->build_log);
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info;

        if($sh_on_error) {
            carp $@ if $@;
            my $pid = fork();
            if($pid == 0) {
                exec("/bin/sh -c 'cd " . $self->build_dir . " && exec \${SHELL:-/bin/sh}'");
                exit -1;
            } elsif($pid > 0) {
                waitpid $pid, 0;
            } else {
                croak 'Could not fork for debugging shell.';
            }
        }
    }
}

sub create_ribbon {
    my ($self) = @_;

    open (my $ribbon_fh, '>', $self->completion_ribbon);
    close $ribbon_fh;
}

sub prepare_recipe_sandbox {
    my ($self, $source) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    my $destination = $self->destination_dir;
    if( -d $destination ) {
        File::Path::rmtree($destination);
    }

    # create the dirs we cleared above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->destination_dir);

    # download to $vc3_distfiles the ingredient (i.e., input file) if missing.
    $source->get_file();

    # copy (or expand if tarball, etc.) input file to build directory
    $source->prepare_file($build);
}

sub execute_recipe {
    my ($self, $source) = @_;

    # if nothing to do, so we return no error:
    return 0 if -f $self->completion_ribbon();

    $self->prepare_recipe_sandbox($source);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $ENV{'VC3_PREFIX'} = $self->destination_dir;

    if($source->file) {
        $ENV{'VC3_SOURCE_FILE'} = $source->file;
    }

    my ($build_in, $pid) = $self->setup_build_shell($source);

    my @steps = @{$source->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    print "Building for '" . $self->name . "' for ", VC3::Bag->target, "\n";
    print "for building details:\ntail -f " . $self->build_log . "\n";

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };

    if(WIFEXITED($?)) {
        $self->create_ribbon();
        return WEXITSTATUS($?);
    } else {
        return -1;
    }
}

sub setup_build_shell {
    my ($self, $source) = @_;

    my ($build_log, $build_in);

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open $build_log,    '>', $self->build_log;
    print { $build_log } join("\n && ", @{$source->recipe}) . "\n";
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my $pid = open($build_in, '|-', '/bin/sh -e');

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";

    # print some debug shell information (e.g., the step about to be executed).
    print { $build_in } "set -x\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($build_in, $pid);
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'service') {
        ...
    }
    elsif($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    else {
        croak "Do not about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Copy;
use File::Fetch;
use File::Path;
use File::Spec;

use Data::Dumper;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->file($json_description->{file});
    $self->dependencies($json_description->{dependencies});

    return $self;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No environment argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub file {
    my ($self, $new_file) = @_;

    $self->{file} = $new_file if($new_file);

    return $self->{file};
}

sub file_absolute {
    my ($self) = @_;

    return File::Spec->rel2abs( $vc3_distfiles . '/' . $self->file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub get_file {
    my ($self) = @_;

    if($self->file) {
        unless(-f $self->file_absolute) {
            print "Downloading '" . $self->file . "' from $vc3_distfiles\n";

            my $ff = File::Fetch->new(uri => $vc3_repository . '/' . $self->file);

            # make sure the destination directory exists
            File::Path::make_path($vc3_distfiles);

            # disable noisy stderr from File::Fetch
            $File::Fetch::BLACKLIST = ['lwp'];
            $ff->fetch( to => $vc3_distfiles );

            if($ff->error || !(-f $self->file_absolute)) {
                croak "Could not download '" . $self->file . "':\n" . $ff->error;
            }
        }
    }
}

sub prepare_file  {
    my ($self, $build_dir) = @_;

    return unless $self->file;

    print "Copying '" . $self->file . "' to build directory.\n";

    File::Copy::copy($self->file_absolute, $build_dir)
    || croak "Could not copy '" . $self->file . "' to build directory.";
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    croak 'No tarball defined.'
    unless $self->file;

    $self = bless $self, $class;

    return $self;
}

sub prepare_file  {
    my ($self, $build_dir) = @_;

    my $tarball = $self->file_absolute;

    print "Expanding $tarball\n";
    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);

    croak "Could not expand tarball $tarball." if $?;
}

package Perl::Version;
use SelfLoader;

package JSON::Tiny;
use SelfLoader;

__DATA__
##### JSON encoding/decoding module:

package JSON::Tiny;

# Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
# License: Artistic 2.0 license.
# http://www.perlfoundation.org/artistic_license_2_0

use strict;
use warnings;
use utf8;
use B qw/svref_2object/;
use Carp qw/carp croak/;
use Exporter 'import';
use Scalar::Util 'blessed';
use Encode ();

our $VERSION = '0.53';
our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);

# Literal names
# Users may override Booleans with literal 0 or 1 if desired.
# our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
our($FALSE, $TRUE) = (0, 1);

# Escaped special character map with u2028 and u2029
my %ESCAPE = (
  '"'     => '"',
  '\\'    => '\\',
  '/'     => '/',
  'b'     => "\x08",
  'f'     => "\x0c",
  'n'     => "\x0a",
  'r'     => "\x0d",
  't'     => "\x09",
  'u2028' => "\x{2028}",
  'u2029' => "\x{2029}"
);
my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;

for(0x00 .. 0x1f) {
  my $packed = pack 'C', $_;
  $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
}

sub decode_json {
  my $err = _decode(\my $value, shift);
  return defined $err ? Carp::croak $err : $value;
}

sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }

sub false () {$FALSE}  ## no critic (prototypes)

sub from_json {
  my $err = _decode(\my $value, shift, 1);
  return defined $err ? Carp::croak $err : $value;
}

sub j {
  return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
  return decode_json $_[0];
}

sub to_json { _encode_value(shift) }

sub true () {$TRUE} ## no critic (prototypes)

sub _decode {
  my $valueref = shift;

  eval {

    # Missing input
    die "Missing or empty input\n" unless length( local $_ = shift );

    # UTF-8
    $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
    die "Input is not UTF-8 encoded\n" unless defined $_;

    # Value
    $$valueref = _decode_value();
  
    # Leftover data
    return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
  } ? return undef : chomp $@;

  return $@;
}

sub _decode_array {
  my @array;
  until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {

    # Value
    push @array, _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\]/gc;

    # Invalid character
    _throw('Expected comma or right square bracket while parsing array');
  }

  return \@array;
}

sub _decode_object {
  my %hash;
  until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {

    # Quote
    m/\G[\x20\x09\x0a\x0d]*"/gc
      or _throw('Expected string while parsing object');

    # Key
    my $key = _decode_string();

    # Colon
    m/\G[\x20\x09\x0a\x0d]*:/gc
      or _throw('Expected colon while parsing object');

    # Value
    $hash{$key} = _decode_value();

    # Separator
    redo if m/\G[\x20\x09\x0a\x0d]*,/gc;

    # End
    last if m/\G[\x20\x09\x0a\x0d]*\}/gc;

    # Invalid character
    _throw('Expected comma or right curly bracket while parsing object');
  }

  return \%hash;
}

sub _decode_string {
  my $pos = pos;
  
  # Extract string with escaped characters
  m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
  my $str = $1;

  # Invalid character
  unless (m/\G"/gc) {
    _throw('Unexpected character or invalid escape while parsing string')
      if m/\G[\x00-\x1f\\]/;
    _throw('Unterminated string');
  }

  # Unescape popular characters
  if (index($str, '\\u') < 0) {
    $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
    return $str;
  }

  # Unescape everything else
  my $buffer = '';
  while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
    $buffer .= $1;

    # Popular character
    if ($2) { $buffer .= $ESCAPE{$2} }

    # Escaped
    else {
      my $ord = hex $3;

      # Surrogate pair
      if (($ord & 0xf800) == 0xd800) {

        # High surrogate
        ($ord & 0xfc00) == 0xd800
          or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');

        # Low surrogate
        $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
          or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');

        $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
      }

      # Character
      $buffer .= pack 'U', $ord;
    }
  }

  # The rest
  return $buffer . substr $str, pos $str, length $str;
}

sub _decode_value {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # String
  return _decode_string() if m/\G"/gc;

  # Object
  return _decode_object() if m/\G\{/gc;

  # Array
  return _decode_array() if m/\G\[/gc;

  # Number
  return 0 + $1
    if m/\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;

  # True
  return $TRUE if m/\Gtrue/gc;

  # False
  return $FALSE if m/\Gfalse/gc;

  # Null
  return undef if m/\Gnull/gc;  ## no critic (return)

  # Invalid character
  _throw('Expected string, array, object, number, boolean or null');
}

sub _encode_array {
  '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
}

sub _encode_object {
  my $object = shift;
  my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
    keys %$object;
  return '{' . join(',', @pairs) . '}';
}

sub _encode_string {
  my $str = shift;
  $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
  return "\"$str\"";
}

sub _encode_value {
  my $value = shift;

  # Reference
  if (my $ref = ref $value) {

    # Object
    return _encode_object($value) if $ref eq 'HASH';

    # Array
    return _encode_array($value) if $ref eq 'ARRAY';

    # True or false
    return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
    return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';

    # Blessed reference with TO_JSON method
    if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
      return _encode_value($value->$sub);
    }
  }

  # Null
  return 'null' unless defined $value;

  # Number
  return $value
    if B::svref_2object(\$value)->FLAGS & (B::SVp_IOK | B::SVp_NOK)
    && 0 + $value eq $value
    && $value * 0 == 0;

  # String
  return _encode_string($value);
}

sub _throw {

  # Leading whitespace
  m/\G[\x20\x09\x0a\x0d]*/gc;

  # Context
  my $context = 'Malformed JSON: ' . shift;
  if (m/\G\z/gc) { $context .= ' before end of data' }
  else {
    my @lines = split "\n", substr($_, 0, pos);
    $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
  }

  die "$context\n";
}

# Emulate boolean type
package JSON::Tiny::_Bool;
use overload '""' => sub { ${$_[0]} }, fallback => 1;
1;

package version;

use 5.006002;
use strict;
use warnings::register;
if ($] >= 5.015) {
    warnings::register_categories(qw/version/);
}

use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);

$VERSION = 0.9917;
$CLASS = 'version';

# !!!!Delete this next block completely when adding to Perl core!!!!
{
    eval "use version::vpp $VERSION"; # don't tempt fate
    die "$@" if ( $@ );
    push @ISA, "version::vpp";
    local $^W;
    *version::qv = \&version::vpp::qv;
    *version::declare = \&version::vpp::declare;
    *version::_VERSION = \&version::vpp::_VERSION;
    *version::vcmp = \&version::vpp::vcmp;
    *version::new = \&version::vpp::new;
    *version::numify = \&version::vpp::numify;
    *version::normal = \&version::vpp::normal;
    if ($] >= 5.009000) {
        no strict 'refs';
        *version::stringify = \&version::vpp::stringify;
        *{'version::(""'} = \&version::vpp::stringify;
        *{'version::(<=>'} = \&version::vpp::vcmp;
        *{'version::(cmp'} = \&version::vpp::vcmp;
        *version::parse = \&version::vpp::parse;
    }
}
else { # use XS module
    push @ISA, "version::vxs";
    local $^W;
    *version::declare = \&version::vxs::declare;
    *version::qv = \&version::vxs::qv;
    *version::_VERSION = \&version::vxs::_VERSION;
    *version::vcmp = \&version::vxs::VCMP;
    *version::new = \&version::vxs::new;
    *version::numify = \&version::vxs::numify;
    *version::normal = \&version::vxs::normal;
    if ($] >= 5.009000) {
        no strict 'refs';
        *version::stringify = \&version::vxs::stringify;
        *{'version::(""'} = \&version::vxs::stringify;
        *{'version::(<=>'} = \&version::vxs::VCMP;
        *{'version::(cmp'} = \&version::vxs::VCMP;
        *version::parse = \&version::vxs::parse;
    }
}
}

# avoid using Exporter
require version::regex;
*version::is_lax = \&version::regex::is_lax;
*version::is_strict = \&version::regex::is_strict;
*LAX = \$version::regex::LAX;
*STRICT = \$version::regex::STRICT;

sub import {
    no strict 'refs';
    my ($class) = shift;

    # Set up any derived class
    unless ($class eq $CLASS) {
	local $^W;
	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
	*{$class.'::qv'} = \&{$CLASS.'::qv'};
    }

    my %args;
    if (@_) { # any remaining terms are arguments
	map { $args{$_} = 1 } @_
    }
    else { # no parameters at all on use line
	%args =
	(
	    qv => 1,
	    'UNIVERSAL::VERSION' => 1,
	);
    }

    my $callpkg = caller();

    if (exists($args{declare})) {
	*{$callpkg.'::declare'} =
	    sub {return $class->declare(shift) }
	  unless defined(&{$callpkg.'::declare'});
    }

    if (exists($args{qv})) {
	*{$callpkg.'::qv'} =
	    sub {return $class->qv(shift) }
	  unless defined(&{$callpkg.'::qv'});
    }

    if (exists($args{'UNIVERSAL::VERSION'})) {
	local $^W;
	*UNIVERSAL::VERSION
		= \&{$CLASS.'::_VERSION'};
    }

    if (exists($args{'VERSION'})) {
	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
    }

    if (exists($args{'is_strict'})) {
	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
	  unless defined(&{$callpkg.'::is_strict'});
    }

    if (exists($args{'is_lax'})) {
	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
	  unless defined(&{$callpkg.'::is_lax'});
    }
}


package version::regex;
use strict;

use vars qw($VERSION $CLASS $STRICT $LAX);

$VERSION = 0.9917;

#--------------------------------------------------------------------------#
# Version regexp components
#--------------------------------------------------------------------------#

# Fraction part of a decimal version number.  This is a common part of
# both strict and lax decimal versions

my $FRACTION_PART = qr/\.[0-9]+/;

# First part of either decimal or dotted-decimal strict version number.
# Unsigned integer with no leading zeroes (except for zero itself) to
# avoid confusion with octal.

my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;

# First part of either decimal or dotted-decimal lax version number.
# Unsigned integer, but allowing leading zeros.  Always interpreted
# as decimal.  However, some forms of the resulting syntax give odd
# results if used as ordinary Perl expressions, due to how perl treats
# octals.  E.g.
#   version->new("010" ) == 10
#   version->new( 010  ) == 8
#   version->new( 010.2) == 82  # "8" . "2"

my $LAX_INTEGER_PART = qr/[0-9]+/;

# Second and subsequent part of a strict dotted-decimal version number.
# Leading zeroes are permitted, and the number is always decimal.
# Limited to three digits to avoid overflow when converting to decimal
# form and also avoid problematic style with excessive leading zeroes.

my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;

# Second and subsequent part of a lax dotted-decimal version number.
# Leading zeroes are permitted, and the number is always decimal.  No
# limit on the numerical value or number of digits, so there is the
# possibility of overflow when converting to decimal form.

my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;

# Alpha suffix part of lax version number syntax.  Acts like a
# dotted-decimal part.

my $LAX_ALPHA_PART = qr/_[0-9]+/;

#--------------------------------------------------------------------------#
# Strict version regexp definitions
#--------------------------------------------------------------------------#

# Strict decimal version number.

my $STRICT_DECIMAL_VERSION =
    qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;

# Strict dotted-decimal version number.  Must have both leading "v" and
# at least three parts, to avoid confusion with decimal syntax.

my $STRICT_DOTTED_DECIMAL_VERSION =
    qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;

# Complete strict version number syntax -- should generally be used
# anchored: qr/ \A $STRICT \z /x

$STRICT =
    qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;

#--------------------------------------------------------------------------#
# Lax version regexp definitions
#--------------------------------------------------------------------------#

# Lax decimal version number.  Just like the strict one except for
# allowing an alpha suffix or allowing a leading or trailing
# decimal-point

my $LAX_DECIMAL_VERSION =
    qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
	|
	$FRACTION_PART $LAX_ALPHA_PART?
    /x;

# Lax dotted-decimal version number.  Distinguished by having either
# leading "v" or at least three non-alpha parts.  Alpha part is only
# permitted if there are at least two non-alpha parts. Strangely
# enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
# so when there is no "v", the leading part is optional

my $LAX_DOTTED_DECIMAL_VERSION =
    qr/
	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
	|
	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
    /x;

# Complete lax version number syntax -- should generally be used
# anchored: qr/ \A $LAX \z /x
#
# The string 'undef' is a special case to make for easier handling
# of return values from ExtUtils::MM->parse_version

$LAX =
    qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;

#--------------------------------------------------------------------------#

# Preloaded methods go here.
sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }

1;


1;

